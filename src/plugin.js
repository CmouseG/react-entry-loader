import getTemplateRunner from './template';


const templateHandlersByLoaderCtx = new WeakMap();

const setTemplateHandler = (loaderCtx, handler)=> (
  templateHandlersByLoaderCtx.set(loaderCtx, handler)
);
export const getTemplateHandler = (loaderCtx)=> (
  templateHandlersByLoaderCtx.get(loaderCtx)
);


const loaderDataByModule = new WeakMap();

const setLoaderData = (module, data)=> loaderDataByModule.set(module, data);
const getLoaderData = (module)=> loaderDataByModule.get(module);


/**
 * Return a `{scripts, styles}` object containing
 * all chunks for a given `entry` separated
 * into js scripts and css style sheets.
 */
const getFiles = (entry)=> {
  const files = [];
  for (const chunk of entry.chunks) {
    files.push(...chunk.files);
  }
  const scripts = files.filter((fle)=> fle.endsWith('.js'));
  const styles = files.filter((fle)=> fle.endsWith('.css'));

  return {scripts, styles};
};


/**
 * Yield all entry modules and their dependencies modules.
 */
function* chunksEntryModules(chunks) {
  for (const {entryModule} of chunks) {
    if (entryModule) {
      yield entryModule;
      for (const {module} of entryModule.dependencies) {
        yield module;
      }
    }
  }
}


/**
 * Yield all entry modules from the `compilation`.
 */
function* entryModules(compilation) {
  for (const [, entry] of compilation.entrypoints.entries()) {
    for (const module of chunksEntryModules(entry.chunks)) {
      yield [entry, module];
    }
  }
}


/**
 * Yield all `[entry, template]` items for every entry module
 * for which a loader has sent this plugin a template.
 */
function* findEntries(compilation) {
  for (const [entry, entryModule] of entryModules(compilation)) {
    const template = getLoaderData(entryModule);
    if (template) {
      yield [entry, entryModule, template];
    }
  }
}


/**
 * Return a tapable hook that will add HTML assets to the `compilation`
 * for every entry module that has a template generated by compatible loaders.
 */
const addHtmlAssets = (compilation)=> async ()=> {
  const genHtml = getTemplateRunner(compilation);

  for (const [entry, module, {output, template}] of findEntries(compilation)) {
    const {scripts, styles} = getFiles(entry);
    const {resource, context} = module;

    const html = await genHtml(resource, context, template, {scripts, styles});

    compilation.assets[output] = {
      source: ()=> html,
      size: ()=> html.length
    };
  }
};


/**
 * Register a callback on the `module` loader `context`.
 *
 * The callback allows any compatible loader to report a template back
 * to this plugin.
 */
const registerModuleLoaderCallback = (loaderCtx, module)=> {
  setTemplateHandler(loaderCtx, (template)=> setLoaderData(module, template));
};


/**
 * Return a tapable hook for the plugin named `name` that registers
 * hooks for the given `compilation` to generate HTML assets for
 * templates set by any compatible loader e.g. `react-entry-loader`.
 */
const getCompilationHook = (name)=> (compilation)=> {
  const {hooks} = compilation;

  hooks.additionalAssets.tapPromise(name, addHtmlAssets(compilation));
  hooks.normalModuleLoader.tap(name, registerModuleLoaderCallback);
};


/**
 * A webpack plugin for generating HTML assets from templates sent by
 * compatible webpack loaders.
 */
class EntryTransformPlugin {
  apply(compiler) {
    const name = this.constructor.name;
    compiler.hooks.thisCompilation.tap(name, getCompilationHook(name));
  }
}

export default EntryTransformPlugin;
